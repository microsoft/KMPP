/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License
 */

#include <stdio.h>
#include <string.h>

#include <openssl/asn1t.h>
#include <openssl/core_names.h>
#include <openssl/core_object.h>
#include <openssl/provider.h>
#include <openssl/x509v3.h>

#include "keyisocertinternal.h"
#include "keyisoclient.h"
#include "keyisoclientprov.h"
#include "keyisoclientinternal.h"
#include "keyisocommon.h"
#include "keyisolog.h"
#include "keyisotelemetry.h"
#include "keyisomemory.h"
#include "keyisopfxclientinternal.h"
#include "p_keyiso.h"
#include "p_keyiso_err.h"

extern KEYISO_CLIENT_CONFIG_ST g_config;
extern KEYISO_KEYSINUSE_ST g_keysinuse;
#define KEYISO_ENCODER_SELF_GENERATED_CERT_FIRST_DNS "pubkey.cert.kmpp.microsoft.com"


KEYISO_PROV_STORE_CTX* KeyIso_store_new_ctx(const char *uri, KEYISO_PROV_PROVCTX *provCtx)
{
    KEYISOP_trace_log(NULL, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "Start");

    KEYISO_PROV_STORE_CTX *storeCtx = NULL;

    if (!uri) {
        KMPPerr(KeyIsoErrReason_FailedToGetUri);
        return storeCtx;
    }

    if (!provCtx) {
        KMPPerr(KeyIsoErrReason_InvalidParams);
        return storeCtx;
    }

    storeCtx = KeyIso_zalloc(sizeof(*storeCtx));
    if (!storeCtx) {
        return storeCtx;
    }

    KEYISOP_trace_log_para(NULL, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "STORE", "uri: %s", uri);
    storeCtx->keyId = KeyIso_strndup(uri, KEYISO_MAX_KEY_ID_LEN);
    storeCtx->provCtx = provCtx;
    storeCtx->status = KeyisoProvStoreStatus_unloaded;
 
    return storeCtx;
}

static KEYISO_PROV_STORE_CTX* _store_open(KEYISO_PROV_PROVCTX *provCtx, const char *uri)
{
    KEYISOP_trace_log(NULL, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "Start");

    if (!uri) {
        KMPPerr(KeyIsoErrReason_FailedToGetUri);
        return NULL;
    }

    if (strncmp(uri, KEYISO_PROV_STORE_SCHEME, sizeof(KEYISO_PROV_STORE_SCHEME) - 1) != 0) {
        // Not our store. Not an Error, just exit.
        KEYISOP_trace_log_error(NULL, KEYISOP_TRACELOG_WARNING_FLAG, KEYISOP_PROVIDER_TITLE, "Not our store", "");
        return NULL;
    }

    return KeyIso_store_new_ctx(uri + sizeof(KEYISO_PROV_STORE_SCHEME), provCtx);
}

static const OSSL_PARAM *_store_settable_ctx_params(ossl_unused void *provCtx)
{
    KEYISOP_trace_log(NULL, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "Start");

    static const OSSL_PARAM known_settable_ctx_params[] = {
        OSSL_PARAM_END
    };
    return known_settable_ctx_params;
}

static int _store_set_ctx_params(ossl_unused KEYISO_PROV_STORE_CTX *ctx, ossl_unused  const OSSL_PARAM params[])
{
    KEYISOP_trace_log(NULL, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "Start");

    return STATUS_OK;
}

bool KeyIso_is_encoder_self_generated_cert(X509 *cert)
{
    STACK_OF(GENERAL_NAME) *sanNames = NULL;    
    bool ret = false;
    size_t maxDnsNameLen = strlen(KEYISO_ENCODER_SELF_GENERATED_CERT_FIRST_DNS);

    if (!cert) {
        return false;
    }

    // Get the Subject Alternative Name (SAN) extension
    sanNames = X509_get_ext_d2i(cert, NID_subject_alt_name, NULL, NULL);
    if (sanNames != NULL) {
        // Get the first SAN entry
        GENERAL_NAME *sanEntry = sk_GENERAL_NAME_value(sanNames, 0);
        if (sanEntry && sanEntry->d.dNSName && sanEntry->type == GEN_DNS) {
            char *dnsName = (char *)ASN1_STRING_get0_data(sanEntry->d.dNSName);
            // Ensure the string is null-terminated
            if (dnsName && dnsName[ASN1_STRING_length(sanEntry->d.dNSName)] == '\0' &&
                ASN1_STRING_length(sanEntry->d.dNSName) == (int)strnlen(dnsName, maxDnsNameLen)) {
                // Check if the first DNS name matches "pubkey.cert.kmpp.microsoft.com"
                if (strncmp(dnsName, KEYISO_ENCODER_SELF_GENERATED_CERT_FIRST_DNS, maxDnsNameLen) == 0) {
                    ret = true;
                }
            }
        }
    }    
    // Free the SAN names stack
    sk_GENERAL_NAME_pop_free(sanNames, GENERAL_NAME_free);
    
    return ret;
}

/*
* Checking if the key is an imported key (not generated by KMPP) which is tied to a valid certificate (not the encoder key generation certificate).
* and only if that is the case, we will monitor the key as part of keys in use.    
*/
static bool _should_key_be_monitored_as_KIU(const uuid_t correlationId, EVP_PKEY *pubKey, X509 *cert)
{   
    if (pubKey && cert && !KeyIso_is_encoder_self_generated_cert(cert)) {
        KEYISOP_trace_log(correlationId, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "The key should indeed be monitored as KIU");
        return true;
    }

    KEYISOP_trace_log(correlationId, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "The key should NOT be monitored as KIU");
    return false;
}

static int _cleanup_rsa_store_load(int ret, KeyIsoErrReason reason, EVP_PKEY *pKey, X509 *pCert, STACK_OF(X509) *ca, 
    char *clientData, unsigned char *pfxBytes, KEYISO_KEY_CTX *keyCtx) 
{
    if (ret != STATUS_OK) {
        KMPPerr(reason);
        // Corner case cleanup: if the provider key was not created, 
        // we need to free explicitly the key context and the public key.
        if (pKey) {
            EVP_PKEY_free(pKey);
            pKey = NULL;
        }
        if (keyCtx) {
            KeyIso_CLIENT_pfx_close(keyCtx);
            keyCtx = NULL;
        }
    }

    if (pCert) {
        X509_free(pCert);
        pCert = NULL;
    }

    if (ca) {
        sk_X509_pop_free(ca, X509_free);
        ca = NULL;
    }
    
    KeyIso_clear_free_string(clientData);
    KeyIso_free(pfxBytes);
    return ret;
}

#define _CLEANUP_RSA_STORE_LOAD(ret, reason) \
        _cleanup_rsa_store_load(ret, reason, pKey, pCert, ca, clientData, pfxBytes, keyCtx)

int KeyIso_store_load(KEYISO_PROV_STORE_CTX *storeCtx, OSSL_CALLBACK *objectCb, void *objectCbArg, 
    ossl_unused OSSL_PASSPHRASE_CALLBACK *pwCb, ossl_unused void* pwCbArg)
{
    KEYISOP_trace_log(NULL, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "Start");

    int ret = 0;
    uuid_t correlationId;
    KEYISO_KEY_CTX *keyCtx = NULL;     // KeyIso_CLIENT_pfx_close()
    int isKeyP8Compatible = 0;
    int isServiceP8Compatible = 0;
    int pfxLength = 0;
    unsigned char *pfxBytes = NULL;     // KeyIso_free()
    char *clientData = NULL;                  // KeyIso_clear_free_string()
    EVP_PKEY *pKey = NULL;
    X509 *pCert = NULL;
    STACK_OF(X509) *ca = NULL;
    KeyIsoErrReason errReason = KeyIsoErrReason_NoError;

    KeyIso_rand_bytes(correlationId, sizeof(correlationId));

    if (!storeCtx || !storeCtx->provCtx) {
        return _CLEANUP_RSA_STORE_LOAD(STATUS_FAILED, KeyIsoErrReason_InvalidStoreCtx);
    }

    // Status will be changed to success at the end.
    storeCtx->status = KeyisoProvStoreStatus_failed;   

    if (!KeyIso_parse_pfx_provider_key_id(correlationId, storeCtx->keyId, &pfxLength, &pfxBytes, &clientData)) {
        return _CLEANUP_RSA_STORE_LOAD(STATUS_FAILED, KeyIsoErrReason_FailedToGetKeyBytes);
    }

    isKeyP8Compatible = !KeyIso_is_oid_pbe2(correlationId, pfxBytes, pfxLength);
    isServiceP8Compatible = (PKCS8_COMPATIBLE == storeCtx->provCtx->p8SrvCompatible);

    if (!KeyIso_open_key_by_compatibility(correlationId, &keyCtx, pfxBytes, pfxLength, clientData, isKeyP8Compatible, isServiceP8Compatible)) {
        return _CLEANUP_RSA_STORE_LOAD(STATUS_FAILED, KeyIsoErrReason_FailedToGetKeyCtx); 
    }
    
   // If the keyCtx does not contain clientData or public key (new KeyId format), we will load it from the PFX's X509 cert  
    if (!KeyIso_load_public_key_by_compatibility(correlationId, keyCtx, isKeyP8Compatible, pfxLength, pfxBytes, &pKey, &pCert, &ca)) {
        return _CLEANUP_RSA_STORE_LOAD(STATUS_FAILED, KeyIsoErrReason_FailedToGetPubKey); 
    }
    
    bool isKIUMonitored = _should_key_be_monitored_as_KIU(correlationId, pKey, pCert);

    if (isKIUMonitored) {
        KeyIso_add_key_to_keys_in_use(correlationId, keyCtx, pKey);
    }

    ret = KeyIso_create_key_object(storeCtx->provCtx, keyCtx, pKey, objectCb, objectCbArg, pwCb, pwCbArg);
    if (ret == STATUS_OK) {
        KEYISOP_trace_log_and_metric_para(correlationId, 0, g_config.solutionType, g_keysinuse.isLibraryLoaded, KEYISOP_PROVIDER_TITLE, "", 
            "key was successfully loaded. Key type: %d. isKeyP8Compatible: %d. isServiceP8Compatible: %d. isDefaultSolutionType: %d.", 
            EVP_PKEY_id(pKey), isKeyP8Compatible, isServiceP8Compatible, g_config.isDefaultSolutionType);
        storeCtx->status = KeyisoProvStoreStatus_success;
        errReason = KeyIsoErrReason_NoError;
    } else {
        storeCtx->status = KeyisoProvStoreStatus_failed;
        errReason = KeyIsoErrReason_OperationFailed;
    }

    return _CLEANUP_RSA_STORE_LOAD(ret, errReason); 
}

int KeyIso_create_key_object(KEYISO_PROV_PROVCTX *provCtx, KEYISO_KEY_CTX *keyCtx, EVP_PKEY *pubKey, OSSL_CALLBACK *objectCb, void *objectCbArg, 
    ossl_unused OSSL_PASSPHRASE_CALLBACK *pwCb, ossl_unused void* pwCbArg)
{   
    KEYISOP_trace_log(NULL, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "Start");

    if (!pubKey) {
        KMPPerr(KeyIsoErrReason_InvalidParams);
        return STATUS_FAILED;
    }

    const char* dataType = NULL;
    unsigned int keyType = 0;
    KEYISO_PROV_PKEY *provKey = NULL;
    
    // Get key type and determine data type and create appropriate provider key
    keyType = EVP_PKEY_base_id(pubKey);
    switch (keyType) {
        case EVP_PKEY_RSA:
            dataType = KEYISO_NAME_RSA;
            provKey = KeyIso_prov_rsa_keymgmt_new(provCtx, keyType);
            break;
        case EVP_PKEY_RSA_PSS:
            dataType = KEYISO_NAME_RSA_PSS;
            provKey = KeyIso_prov_rsa_keymgmt_new(provCtx, keyType);
            break;
        case EVP_PKEY_EC:
            dataType = KEYISO_NAME_EC;
            provKey = KeyIso_prov_ecc_keymgmt_new(provCtx);
            break;
        default:
            KMPPerr(KeyIsoErrReason_UnsupportedKeyType);
            return STATUS_FAILED;
    }

    if (!provKey) {
        // Failed to create new KEYISO_PROV_PKEY
        return STATUS_FAILED;
    }

    // Set the keyCtx and pubKey in the KEYISO_PROV_PKEY
    provKey->keyCtx = keyCtx;
    provKey->pubKey = pubKey;    

    // Construct the parameters for the object callback
    OSSL_PARAM paramsPkey[4];
    int objectType = OSSL_OBJECT_PKEY;
    paramsPkey[0] = OSSL_PARAM_construct_int(OSSL_OBJECT_PARAM_TYPE, &objectType);
    paramsPkey[1] = OSSL_PARAM_construct_utf8_string(OSSL_OBJECT_PARAM_DATA_TYPE, (char *)dataType, 0);
    paramsPkey[2] = OSSL_PARAM_construct_octet_string(OSSL_OBJECT_PARAM_REFERENCE, &provKey, sizeof(provKey));
    paramsPkey[3] = OSSL_PARAM_construct_end();
    int ret = objectCb(paramsPkey, objectCbArg);
    if (!ret) {
        // Clean up provider key based on type
        if (keyType == EVP_PKEY_EC) {
            KeyIso_ecc_keymgmt_free(provKey);
        } else {
            KeyIso_rsa_keymgmt_free(provKey);
        }
        KMPPerr(KeyIsoErrReason_OperationFailed);
        return STATUS_FAILED;
    }
    return STATUS_OK;
}

// Checks if the end of the RSA store context is reached
static int _store_eof(KEYISO_PROV_STORE_CTX *ctx)
{
    KEYISOP_trace_log(NULL, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "Start");

    int isEofReached = 1;

    if (!ctx) {
        KMPPerr(KeyIsoErrReason_InvalidStoreCtx);
        return isEofReached;
    }

    // In failure we still may retrieve some data, keep going
    if (ctx->status != KeyisoProvStoreStatus_failed)
        isEofReached = 0;    

    return isEofReached;
}

int KeyIso_store_close(KEYISO_PROV_STORE_CTX *storeCtx)
{
    KEYISOP_trace_log(NULL, KEYISOP_TRACELOG_VERBOSE_FLAG, KEYISOP_PROVIDER_TITLE, "Start");

    if (storeCtx == NULL) {
        return STATUS_OK;
    }
    
    KeyIso_clear_free_string(storeCtx->keyId);
    KeyIso_clear_free(storeCtx, sizeof(KEYISO_PROV_STORE_CTX));

    return STATUS_OK;
}

const OSSL_DISPATCH keyIso_prov_store_funcs[] = {
    { OSSL_FUNC_STORE_OPEN, (void (*)(void))_store_open },
    { OSSL_FUNC_STORE_SETTABLE_CTX_PARAMS, (void (*)(void))_store_settable_ctx_params },
    { OSSL_FUNC_STORE_SET_CTX_PARAMS, (void (*)(void))_store_set_ctx_params },
    { OSSL_FUNC_STORE_LOAD, (void (*)(void))KeyIso_store_load },
    { OSSL_FUNC_STORE_EOF, (void (*)(void))_store_eof },
    { OSSL_FUNC_STORE_CLOSE, (void (*)(void))KeyIso_store_close },
    { 0, NULL }
};
